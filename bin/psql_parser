#!/usr/bin/env ruby

require_relative '../lib/psql_parser.rb'

output_errors = true
parser = ::PsqlParser.parser

sql = ARGV.first

def output_error(sql, parser)
  fail_index = parser.max_terminal_failure_index
  STDERR.flush
  STDOUT.flush
  STDERR.puts( "\n" +
                 (fail_index > 0) ? sql[0..(fail_index - 1)] : "" +
                 sql[(fail_index)..-1] +
                 "\n\n")

  STDERR.flush
end

def clean_tree(root_node)
  return if(root_node.elements.nil?)
  root_node.elements.delete_if{|node| node.class.name == "Treetop::Runtime::SyntaxNode" }
  root_node.elements.each {|node| self.clean_tree(node) }
end

def reload
  Object.send(:remove_const, :SqlParser) rescue nil
  Object.send(:remove_const, :Sql) rescue nil
  TestChamber.send(:remove_const, :PARSER) rescue nil

  load(File.join(PSQLPARSER_BASE_PATH, 'psql_node_extensions.rb'))
  Treetop.load(File.join(PSQLPARSER_BASE_PATH, 'psql_parser.treetop'))
  PSqlParser.extend(PSqlParserHelpers)
  load(__FILE__)
end

PSqlParser.parse(sql).tap do |tree|
  # If the AST is nil then there was an error during parsing
  # we need to report a simple error message to help the user
  if tree.nil?
    # output_error(sql, parser) if output_errors
    raise Exception, parser.failure_reason if output_errors
  end
end

