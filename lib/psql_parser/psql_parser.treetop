grammar PSql

  rule wholefile
    sn
    (content_line / sN)*
    sn
  end


  rule content_line
    [ \t]* [\S]+ [^\n]* [\n]
  end


  rule ddl_or_query
    maybe_spaces
    (query / ddl_statement)
    maybe_spaces
    <DDLorQuery>
  end

  rule ddl_statement
    maybe_spaces
     ( create_table /
      grant_or_revoke_statement /
      set_statement /
      comment_on_stmt /
      create_sequence /
      alter_sequence )
      maybe_spaces
     [';']? maybe_spaces
    <DDLStatement>
  end

  rule query
    req_space_or_comment*
    select_statement
    (req_space_or_comment from_statement (req_space_or_comment join_statement)*
      (req_space_or_comment where_statement)?
      (req_space_or_comment group_by_statement)?
      (req_space_or_comment having_statement)?
      (req_space_or_comment window_statement)*
      (req_space_or_comment order_by_statement)?
      (req_space_or_comment limit_statement)?
      )?
    (req_space_or_comment* 'union' req_space_or_comment query)?
    (req_space_or_comment / ';')*
    <Query>
  end

  rule comment_line
    ('--' [^\n]*)
    <CommentLine>
  end

  rule select_statement
    'select' req_space_or_comment (distinct_predicate req_space_or_comment)? select_expressions
     <SelectStatement>
  end

  rule join_statement
    ('left' / 'outer' / 'inner' / 'right' / 'full' / req_space_or_comment)* 'join' req_space_or_comment expression (req_space_or_comment alias)? req_space_or_comment 'on' req_space_or_comment expression
    <JoinStatement>
  end

  rule where_statement
    'where' req_space_or_comment expression
    <WhereStatement>
  end

  rule having_statement
    'having' req_space_or_comment expression
    <HavingClause>
  end

  rule window_statement
    'window' req_space_or_comment field_entity req_space_or_comment 'as' req_space_or_comment window
    <WindowStatement>
  end

  rule group_by_statement
    'group by' req_space_or_comment expression (items_separator expression)*
     <GroupByClause>
  end

  rule order_by_statement
    'order by' req_space_or_comment order_by_expression (items_separator order_by_expression)*
     <Statement>
  end

  rule limit_statement
    'limit' req_space_or_comment [0-9]+
    <StatementClause>
  end

  rule select_expressions
    select_expression (items_separator select_expression)* <Entity>
  end

  rule items_separator
    maybe_spaces ',' maybe_spaces
    <ListSeparator>
  end

  rule order_by_expression
    expression (req_space_or_comment ('desc' / 'asc'))?
    <OrderByClause>
  end

  rule select_expression
    expression (req_space_or_comment alias)? <SelectExpression>
  end

  rule alias
    ('as' req_space_or_comment)?
    (
      '"' ([^\"]+ <Alias>) '"'
      /
      !(keyword word_boundary) [\w]+ <Alias>
    )
  end

  # one or more spaces (required)
  rule sps
    [\s]+
  end


  rule create_table
    'create' sps 'table' sps  opt_schema_table_name columns
    <CreateTable>
  end

  rule columns
    maybe_spaces '(' maybe_spaces column_name sps data_type maybe_spaces  ')'
  end

  rule next_column
    items_separator column_specification
  end


  rule alter_table
    'alter' sps 'table' sps ( 'if exists' sps)? ( 'only' sps)? table_name
      ( sps '*'  )
    <AlterTable>
  end


  rule table_scope
    ( ( ( 'global' / 'local') sps)*  ('temporary' / 'temp') )* ('unlogged')*
     <TableScope>
  end

  # The optionally schema-qualified name of a table
  rule opt_schema_table_name
    ( [\w_]+ '.' )? [\w_]+
    <OptionalSchemaTableName>
  end

 # ( ( sps constraint_definition )?
#          ( sps column_collation )?
#          ( sps deferrable_clause)?
#          ( sps immediate_clause)?
#          ( sps column_constraint)* )?
  rule column_specification
    maybe_spaces column_name sps data_type maybe_spaces
    <ColumnSpecification>
  end


  rule column_name
    [\w]+
    <ColumnName>
  end

  rule column_collation
    'collate' sps [\w_\.]+
    <ColumnCollateClause>
  end

  rule column_constraint
    ( default_expression maybe_spaces ) /
    ( primary_key_definition maybe_spaces ) /
    ( unique_definition maybe_spaces ) /
    ( null_or_not_clause maybe_spaces ) /
    ( check_expression maybe_spaces ) /
    ( references_definition maybe_spaces )
    <ColumnConstraint>
  end

  rule deferrable_clause
     'deferrable' / 'not deferrable'
    <DeferrableClause>
  end

  rule immediate_clause
     'initially deferred' / 'initially immediate'
     <ImmediateClause>
  end

  rule constraint_definition
    'constraint' sps [\w_]+
    <ConstraintDefinition>
  end

  rule null_or_not_clause
    'null' / 'not null'
    <NullOrNotClause>
  end

  rule default_expression
    'default' sps expression
    <DefaultExpression>
  end

  rule primary_key_definition
    'primary key'
      (sps columns_in_parentheses )?
      (sps (using_index_tablespace_parameters)? )?
      <PrimaryKeyDefinition>
  end

  rule unique_definition
    'unique'
      (sps columns_in_parentheses )?
      (sps (using_index_tablespace_parameters)? )?
      <UniqueDefinition>
  end

  rule check_expression
    'check'
      ( sps '(' maybe_spaces expression maybe_spaces ')' )?
      ( sps 'no inherit' maybe_spaces)?
      <CheckExpression>
  end

  rule references_definition
    'references' sps opt_schema_table_name
      ( sps '(' maybe_spaces column_name maybe_spaces ')' )?
      ( sps ('match full' / 'match partial' / 'match simple') )?
      <ReferencesDefinition>
  end

  rule columns_in_parentheses
   ( '(' maybe_spaces column_name (',' sps column_name)* maybe_spaces ')' maybe_spaces)
   <ColumnsInParentheses>
  end

  # TODO: This is incomplete. It does not include the '[ WITH ( storage_parameter [= value] [, ... ] ) ]' clause
  rule using_index_tablespace_parameters
    (maybe_spaces 'using index tablespace' sps opt_schema_table_name)
    <UsingIndexTablespaceParameters>
  end


 rule grant_or_revoke_statement
   ('grant' / 'revoke') sps role_names sps 'on schema' sps schema_name sps 'to' sps role_specifications
     (sps 'with admin option')?
     (sps 'granted by' sps role_specifications)?
     <GrantOrRevokeStatement>
 end

  rule role_names
    role_name (maybe_spaces ',' maybe_spaces role_name )*
    <RoleNames>
  end

  rule role_specifications
    role_specification (maybe_spaces ',' maybe_spaces role_specification )*
    <RoleSpecifications>
  end

  rule role_specification
   ('group' req_space_or_comment)? role_name / 'public' / 'current_user' / 'session_user'
   <RoleSpecifications>
  end

  # not schema qualified
  rule table_name
    [\w_]+
    <TableName>
  end

  rule schema_name
    [\w_]+
    <SchemaName>
  end

  rule role_name
    [\w_]+
    <RoleName>
  end

  rule set_statement
    'set' sps (session_local_scope sps)?
       configuration_parameter
       ( ( sps 'to' sps ) / ( maybe_spaces '=' maybe_spaces ) ) primitive_literal
       <SetConfigParamStatement>
  end

  rule session_local_scope
    'session' / 'local'
    <SessionLocalScope>
  end

  rule configuration_parameter
    [\w_.]+ <ConfigParameter>
  end

  rule comment_on_stmt
    ( 'comment' sps 'on' sps
       ( comment_target_on_object /
        comment_target_aggregate /
        procedural_language_comment_target
      )
    ) sps 'is' sps "'" comment_text "'"
    <CommentOnStatement>
  end

  rule comment_text
    [^']+
    <CommentText>
  end

  rule comment_target_aggregate
   'aggregate' sps aggregate_name sps '(' maybe_spaces aggregate_signature maybe_spaces ')'
    <CommentTargetAggregate>
  end

  rule aggregate_name
    [\w_]+
    <AggregateName>
  end

  rule argmode
    'inout' / 'in' / 'out' / 'variadic'
    <AggregateMode>
  end

  # TODO: this isn't really accurate.  but it'll cover lots of cases
  rule argtype
    data_type
    <AggregateType>
  end

  rule argtypes
    data_type ( items_separator argtype)*
    <AggregateTypes>
  end

  rule arg_mode_name_type
    (argmode req_space_or_comment)? (aggregate_name req_space_or_comment)? data_type
    <AggregateModeNameTypesClause>
  end


  rule aggregate_signature
    '*' <AggregateSignature> / arg_mode_name_type (items_separator arg_mode_name_type)?  <AggregateSignature> /
     ( (argmode sps)? 'order by' sps arg_mode_name_type (items_separator arg_mode_name_type)? ) <AggregateSignature>
  end


  rule procedural_language_comment_target
    [\w_]+
    <ProceduralLanguageCommentTarget>
  end

  rule comment_target_on_object
    comment_target_object req_space_or_comment comment_object_name
    <CommentTargetOnObjectClause>
  end

  rule comment_target_object
    'access method' /
    'cast' /
    'collation' /
    'column' /
    'constraint' /
    'conversion' /
    'database' /
    'domain' /
    'extension' /
    'event trigger' /
    'foreign table' /
    'foreign data wrapper' /
    'function' /
    'index' /
    'large object' /
    'materialized view' /
    'operator' /
    'operator class' /
    'operator family'  /
    'policy' /
    'role' /
    'rule' /
    'schema' /
    'sequence' /
    'server' /
    'table' /
    'tablespace' /
    'text search configuration' /
    'text search dictionary' /
    'text search parser' /
    'text search template' /
    'transform for' /
    'trigger'  /
    'type'/
    'view'
    <CommentTargetObjectKeyword>
  end

  rule comment_object_name
    [\w_]+
    <CommentTargetObjectName>
  end


  rule create_sequence
    'create' req_space_or_comment 'sequence' req_space_or_comment ( 'temporary' req_space_or_comment)? sequence_name
      (seq_increment_clause /
           seq_start_with_clause /
           seq_minval_clause /
           seq_maxval_clause /
           seq_cache_clause /
           seq_cycle_clause /
           if_not_exists_clause /
           seq_owned_by_clause )*
    <CreateSequence>
  end

  # TODO: why doesn't this work when I use it in create_sequence?
  rule sequence_clause
    ( seq_increment_clause /
      seq_start_with_clause /
      seq_minval_clause /
      seq_maxval_clause /
      seq_cache_clause /
      seq_cycle_clause /
      if_not_exists_clause /
      seq_owned_by_clause )
    <SequenceClause>
  end

  rule alter_sequence
     'alter sequence' req_space_or_comment ( 'if exists' req_space_or_comment )? sequence_name
          ( alter_sequence_clause* ) /
          alter_seq_rename /
          alter_seq_change_owner /
          alter_seq_change_schema
     <AlterSequence>
  end

  rule alter_seq_rename
    req_space_or_comment 'rename to' req_space_or_comment sequence_name
    <AlterSequenceRenameClause>
  end

  rule alter_seq_change_owner
    req_space_or_comment 'owned by' req_space_or_comment sequence_name
    <AlterSequenceChangeOwnerClause>
  end

  rule alter_seq_change_schema
    req_space_or_comment 'set schema' req_space_or_comment [\w_]+
    <AlterSequenceChangeSchemaClause>
  end

  rule alter_sequence_clause
    seq_owned_by_clause /
    seq_increment_clause /
    seq_minval_clause /
    seq_maxval_clause /
    seq_start_with_clause /
    seq_cache_clause /
    seq_cycle_clause /
    alter_seq_rename /
    alter_seq_change_schema /
    ( req_space_or_comment 'restart' req_space_or_comment ( 'with' req_space_or_comment )? pos_neg_integer+)
    <AlterSequenceClause>
  end


  rule sequence_name
    ( schema_name '.' )? (table_name '.' )? column_name
    <SequenceName>
  end

  rule if_not_exists_clause
    req_space_or_comment 'if not exists'
    <IfNotExistsClause>
  end

  rule seq_start_with_clause
    req_space_or_comment 'start' req_space_or_comment ( 'with' req_space_or_comment )? pos_neg_integer+
    <StartsWithClause>
  end

  rule seq_increment_clause
    req_space_or_comment 'increment' req_space_or_comment ( 'by' req_space_or_comment )? pos_neg_integer+
    <IncrementClause>
  end

  rule seq_minval_clause
     (req_space_or_comment 'minvalue' req_space_or_comment pos_neg_integer+ ) / (req_space_or_comment 'no minvalue' )
     <MinValueClause>
  end

  rule seq_maxval_clause
    (req_space_or_comment 'maxvalue' req_space_or_comment pos_neg_integer+ ) / (req_space_or_comment 'no maxvalue' )
    <MaxValueClause>
  end

  rule seq_cache_clause
    req_space_or_comment 'cache' req_space_or_comment cache_name
    <CacheClause>
  end

  rule seq_cycle_clause
    req_space_or_comment ( 'no' req_space_or_comment)?  'cycle'
    <CycleClause>
  end

  rule seq_owned_by_clause
    req_space_or_comment  'owned by' req_space_or_comment ( sequence_name / 'none' )
    <OwnedByClause>
  end

  rule cache_name
    [\w_]+
    <CacheName>
  end

  rule owner_name
    [\w_]+
    <OwnerName>
  end

  # FIXME
   rule seq_time_scope
     'temporary'
     <SequenceTempTimeScope>
  end

  rule pos_neg_integer
    ( '+' / '-' )? [0-9]+
    <PosNegInteger>
  end

 #--------------------------------------------------
  rule expression
    prefix_modifier?
    (
      '(' query ')' <Query>
      /
      '(' req_space_or_comment? expression req_space_or_comment? ')' <Entity>
      /
      sub_expression)
    (req_space_or_comment? inline_window)?
    ('::' [\w]+)? # cast
    (req_space_or_comment? set_operator req_space_or_comment? (set))*
    (req_space_or_comment? operator req_space_or_comment? expression)?
  end

  rule prefix_modifier
    'not' req_space_or_comment
    /
    '-' req_space_or_comment?
  end

  rule inline_window
    'over' req_space_or_comment (window / field_entity)
  end

  # poor window parsing right now... we'll need to beef this up if we use windows with parentheses
  rule window
    '(' [^\)]* ')'
  end

  rule set
    set_literal
    /
    '(' query ')'
  end

  rule distinct_predicate
    'distinct' / 'all'
  end

  rule set_literal
    '(' req_space_or_comment? primitive_literal (req_space_or_comment? ',' req_space_or_comment? primitive_literal)* req_space_or_comment? ')'
  end

  rule primitive_literal
    interval_literal / numeric_literal / string_literal
  end

  rule interval_literal
    'interval' req_space_or_comment "'" [\w ]+ "'"
  end

  rule numeric_literal
    [0-9]+ ("." [0-9]+)?
  end

  rule sub_expression
    case_statement
    /
    function
    /
    primitive_literal
    /
    field_entity
  end

  rule set_operator
    'not in' / 'in' &req_space_or_comment
  end

  rule operator
    [+\-/=\|><!]+
    /
    ('is not' / 'is' / 'like' / 'between' / 'and' / 'or') &req_space_or_comment
  end

  rule case_statement
    'case'
    (req_space_or_comment !('when') expression)?
    (req_space_or_comment 'when' req_space_or_comment expression req_space_or_comment 'then' req_space_or_comment expression)*
    (req_space_or_comment 'else' req_space_or_comment expression)?
    req_space_or_comment 'end' <Entity>

  end

  rule function
    [\w]+ req_space_or_comment* '(' (distinct_predicate req_space_or_comment)? (expression / ',' / req_space_or_comment)* ')'
    <Function>
  end

  rule string_literal
    "'" [^\']+ "'"
  end

  rule name_expression
    '"' ([^\"]+ <Name>) '"'
    /
    [\w]+ <Name>
  end

  rule field_entity
    '"' [\w\.\* ]+ '"' <QuotedEntity>
    /
    [\w\.\*]+ <Entity>
  end

  rule field_glob
    '*' <FieldGlob>
  end

  rule field_reference
    (name_expression "." <TablePart>)? (name_expression / field_glob) <FieldRef>
  end

  rule from_statement
    'from' req_space_or_comment+ from_expression (req_space_or_comment alias)? <Statement>
  end

  rule from_expression
    [\w]+ <Entity>
    /
    '(' query ')' <Entity>
  end


  rule maybe_spaces
    [\s]*
  end

  # matches at least one space. Handles comments, too.
  rule req_space_or_comment
    ([\s]+ / ('--' (!"\n" .)+ ))+
    <Space>
  end

  rule word_boundary
    ![\w]
  end

  rule keyword
    # 'select' / 'from' / 'inner' / 'outer' / 'full' / 'left' / 'right' / 'join' / 'on' / 'where' / 'group by' / 'order by' / 'having' / 'limit' / 'union'
    (
      'all' / 'analyse' / 'analyze' / 'and' / 'any' / 'array' / 'asc' / 'as' /
      'binary' / 'both' /
      'case' / 'cast' / 'check' / 'column' / 'constraint' / 'correlation' / 'create' / 'current_database' / 'current_date' / 'current_schema' / 'current_timestamp' / 'current_time' / 'current_user' /
      'default' / 'deferrable' / 'desc' / 'distinct' / 'do' /
      'else' / 'encoded' / 'end' / 'except' /
      'false' / 'foreign' / 'for' / 'from' /
      'grant' / 'grouped' / 'group' /
      'having' /
      'initially' / 'intersect' / 'intervalym'  / 'into' / 'in' /
      'join' /
      'ksafe' /
      'leading' / 'limit' / 'localtimestamp' / 'localtime' /
      'match' /
      'new' / 'not' / 'nullsequal' / 'null' /
      'offset' / 'off' / 'old' / 'only' / 'on' / 'order' / 'or' /
      'pinned' / 'placing' / 'primary' / 'projection' /
      'references' /
      'schema' / 'segmented' / 'select' / 'session_user' / 'set' / 'some' / 'sysdate' /
      'table' / 'then' / 'timeseries' / 'to' / 'trailing' / 'true' /
      'unbounded' / 'union' / 'unique' / 'unsegmented' / 'user' / 'using' /
      'when' / 'where' / 'window' / 'within' / 'with'
    )
    word_boundary
    <SQLKeyword>
  end


  #   bit varying [ (n) ]	varbit [ (n) ]
  # TODO how to handle 'bit varying' ?
  rule bit_varying_type
    ( 'bit varying'  /  'bit' / 'varbit' ) integer_in_parenthese?
    <BitVaryingType>
  end

  # character [ (n) ]	char [ (n) ]
  rule character_type
   (  'character' / 'char') integer_in_parenthese?
   <CharacterType>
  end

  # character varying [ (n) ]	varchar [ (n) ]
  #  TODO: how to handle 'character varying'  vs. character_type?
  rule character_varying_type
    ( 'character varying' / 'varchar' ) integer_in_parenthese?
    <VarCharType>
  end

  rule integer_in_parenthese
    ( '(' maybe_spaces [0-9]+ maybe_spaces ')' )
    <IntegerInParentheses>
  end

  #  numeric [ (p, s) ]	decimal [ (p, s) ]
  rule numeric_type
    ('numeric' / 'decimal' ) ( '(' maybe_spaces [0-9]+ (maybe_spaces ',' maybe_spaces [0-9]+)?  maybe_spaces ')' )?
    <NumericType>
  end

  #  float [ (p, s) ]	decimal [ (p, s) ]
  rule float_type
    ('float' ) ( '(' maybe_spaces [0-9]+ (maybe_spaces ',' maybe_spaces [0-9]+)?  maybe_spaces ')' )?
    <FloatType>
  end

  # FIXME interval type: fields, precision of the fields, etc.
  # interval [ fields ] [ (p) ]
  rule interval_type
    'interval'
    <IntervalType>
  end

  # Usage: colname integer NOT NULL DEFAULT nextval('tablename_colname_seq')
  rule nextval_function_call
    '(' maybe_spaces "'" name_expression  "'" maybe_spaces ')'
    <NextValFunctionCall>
  end


  rule time_timestamp_type
    ('timestamp' / 'time' ) (integer_in_parenthese)? ((sps 'without time zone' ) / (sps 'with time zone'))?
    <TimestampType>
  end

  rule with_or_without_timezone_stmt
    (sps 'without time zone' ) / (sps 'with time zone')
     <WithOrWithoutTimeZoneClause>
  end

  # Order is important!
  rule data_type
    (
    'bigint' /	'int8' /
    'bigserial' /	'serial8' /
     bit_varying_type /
    'boolean' /	'bool' /
    'box' /
    'bytea' /
     character_varying_type /
     character_type /

    'cidr' /
    'circle' /
    'date' /
    'double precision' /	'float8' /
    float_type /
    'inet' /
    'integer' /	'int' / 'int4' /
    interval_type /
    'json' /
    'jsonb' /
    'line' /
    'lseg' /
    'macaddr' /
    'money' /
     numeric_type /
    'path' /
    'pg_lsn' /
    'point' /
    'polygon' /
    'real' /	'float4' /
    'smallint' /	'int2' /
    'smallserial' /	'serial2' /
    'serial' /	'serial4' /
    'text' /
    time_timestamp_type /
    'tsquery' /
    'tsvector' /
    'txid_snapshot' /
    'uuid' /
    'xml'
    )
    word_boundary
    <DataType>
  end


  # =============================
  #  Whitespace and comments
  # =============================

  # optional space
  rule s
    S?
  end

  # one or more spaces or tabs
  rule S
    [ \t]+
  end

  # optional blank line
  rule sn
    sN?
  end

  rule comment_line
    comment_marker (!"\n" .)* "\n"  <CommentLine>
  end

  rule comment_marker
    '--'
  end

  # optional spaces followed by a newline
  #   or
  # comment line preceded by optional spaces
  rule sN
    ( ( S "\n" / s comment_line / s "\n" ) s comment_line? )+  <SN>
  end

end
