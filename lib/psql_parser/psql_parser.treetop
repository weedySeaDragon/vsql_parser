grammar PSql

  rule wholefile
    sn
    (ddl_or_query / sN)*
    sn
  end

  # ddl_statement must come before query so that any ddl statements that start
  #  with query keywords are properly parsed (e.g. 'SELECT ...set_config()'
  rule ddl_or_query
    s
    (query )
    s
    #    <DDLorQuery>
  end

  rule query
    req_space_or_comment*
    select_statement
    (req_space_or_comment from_statement (req_space_or_comment join_statement)*
      (req_space_or_comment where_statement)?
      (req_space_or_comment group_by_statement)?
      (req_space_or_comment having_statement)?
      (req_space_or_comment window_statement)*
      (req_space_or_comment order_by_statement)?
      (req_space_or_comment limit_statement)?
      )?
    (req_space_or_comment* 'union' req_space_or_comment query)?
    (req_space_or_comment / ';')*
    #    <Query>
  end


  rule select_statement
    'select' req_space_or_comment (distinct_predicate req_space_or_comment)? select_expressions
    #     <SelectStatement>
  end

  rule join_statement
    ('left' / 'outer' / 'inner' / 'right' / 'full' / req_space_or_comment)* 'join' req_space_or_comment expression (req_space_or_comment alias)? req_space_or_comment 'on' req_space_or_comment expression
    #    <JoinStatement>
  end

  rule where_statement
    'where' req_space_or_comment expression
    #    <WhereStatement>
  end

  rule having_statement
    'having' req_space_or_comment expression
    #    <HavingClause>
  end

  rule window_statement
    'window' req_space_or_comment field_entity req_space_or_comment 'as' req_space_or_comment window
    #    <WindowStatement>
  end

  rule group_by_statement
    'group by' req_space_or_comment expression (list_separator expression)*
    #     <GroupByClause>
  end

  rule order_by_statement
    'order by' req_space_or_comment order_by_expression (list_separator order_by_expression)*
     # <Statement>
  end

  rule limit_statement
    'limit' req_space_or_comment [0-9]+
    # <StatementClause>
  end

  rule select_expressions
    select_expression (list_separator select_expression)* # <Entity>
  end

  rule order_by_expression
    expression (req_space_or_comment ('desc' / 'asc'))?
    #    <OrderByClause>
  end

  rule select_expression
    expression (req_space_or_comment alias)?  #<SelectExpression>
  end

  rule alias
    ('as' req_space_or_comment)?
    (
      '"' ([^\"]+ ) '"'
      /
      !(keyword word_boundary) [\w]+ #<Alias>
    )
  end



  # not schema qualified
  rule table_name
    [\w]+
      #    <TableName>
  end

  rule schema_name
    [\w]+
      #    <SchemaName>
  end

  rule role_name
    [\w]+
      #    <RoleName>
  end


  rule cache_name
    [\w]+
    #    <CacheName>
  end

  rule owner_name
    [\w]+
    #    <OwnerName>
  end


  rule pos_neg_integer
    ( '+' / '-' )? [0-9]+
    #    <PosNegInteger>
  end

 #--------------------------------------------------
  rule expression
    prefix_modifier?
    (
      '(' query ')' #<Query>
      /
      '(' req_space_or_comment? expression req_space_or_comment? ')' #<Entity>
      /
      sub_expression)
    (req_space_or_comment? inline_window)?
    ('::' [\w]+)? # cast
    (req_space_or_comment? set_operator req_space_or_comment? (set))*
    (req_space_or_comment? operator req_space_or_comment? expression)?
  end

  rule prefix_modifier
    'not' req_space_or_comment
    /
    '-' req_space_or_comment?
  end

  rule inline_window
    'over' req_space_or_comment (window / field_entity)
  end

  # poor window parsing right now... we'll need to beef this up if we use windows with parentheses
  rule window
    '(' [^\)]* ')'
  end

  rule set
    set_literal
    /
    '(' query ')'
  end

  rule distinct_predicate
    'distinct' / 'all'
  end

  rule set_literal
    '(' req_space_or_comment? primitive_literal (req_space_or_comment? ',' req_space_or_comment? primitive_literal)* req_space_or_comment? ')'
  end

  rule primitive_literal
    interval_literal / numeric_literal / string_literal
  end

  rule interval_literal
    'interval' req_space_or_comment "'" [\w ]+ "'"
  end

  rule numeric_literal
    [0-9]+ ("." [0-9]+)?
  end

  rule sub_expression
    case_statement
    /
    function
    /
    primitive_literal
    /
    field_entity
  end

  rule set_operator
    'not in' / 'in' &req_space_or_comment
  end

  rule operator
    [+\-/=\|><!]+
    /
    ('is not' / 'is' / 'like' / 'between' / 'and' / 'or') &req_space_or_comment
  end

  rule case_statement
    'case'
    (req_space_or_comment !('when') expression)?
    (req_space_or_comment 'when' req_space_or_comment expression req_space_or_comment 'then' req_space_or_comment expression)*
    (req_space_or_comment 'else' req_space_or_comment expression)?
    req_space_or_comment 'end' # <Entity>

  end

  rule function
    [\w]+ req_space_or_comment* '(' (distinct_predicate req_space_or_comment)? (expression / ',' / req_space_or_comment)* ')'
      #    <Function>
  end

  rule string_literal
    "'" [^\']+ "'"
  end

  rule name_expression
    '"' ([^\"]+ <Name>) '"'
    /
    [\w]+ #<Name>
  end

  rule field_entity
    '"' [\w\.\* ]+ '"' #<QuotedEntity>
    /
    [\w\.\*]+ #<Entity>
  end

  rule field_glob
    '*' #<FieldGlob>
  end

  rule field_reference
    (name_expression "." <TablePart>)? (name_expression / field_glob) #<FieldRef>
  end

  rule from_statement
    'from' req_space_or_comment+ from_expression (req_space_or_comment alias)? #<Statement>
  end

  rule from_expression
    [\w]+ #<Entity>
    /
    '(' query ')' #<Entity>
  end


  # matches at least one space. Handles comments, too.
  rule req_space_or_comment
    ([\s]+ / ('--' (!"\n" .)+ ))+
    #    <Space>
  end

  rule word_boundary
    ![\w]
  end

  rule keyword
    # 'select' / 'from' / 'inner' / 'outer' / 'full' / 'left' / 'right' / 'join' / 'on' / 'where' / 'group by' / 'order by' / 'having' / 'limit' / 'union'
    (
      'all' / 'analyse' / 'analyze' / 'and' / 'any' / 'array' / 'asc' / 'as' /
      'binary' / 'both' /
      'case' / 'cast' / 'check' / 'column' / 'constraint' / 'correlation' / 'create' / 'current_database' / 'current_date' / 'current_schema' / 'current_timestamp' / 'current_time' / 'current_user' /
      'default' / 'deferrable' / 'desc' / 'distinct' / 'do' /
      'else' / 'encoded' / 'end' / 'except' /
      'false' / 'foreign' / 'for' / 'from' /
      'grant' / 'grouped' / 'group' /
      'having' /
      'initially' / 'intersect' / 'intervalym'  / 'into' / 'in' /
      'join' /
      'ksafe' /
      'leading' / 'limit' / 'localtimestamp' / 'localtime' /
      'match' /
      'new' / 'not' / 'nullsequal' / 'null' /
      'offset' / 'off' / 'old' / 'only' / 'on' / 'order' / 'or' /
      'pinned' / 'placing' / 'primary' / 'projection' /
      'references' /
      'schema' / 'segmented' / 'select' / 'session_user' / 'set' / 'some' / 'sysdate' /
      'table' / 'then' / 'timeseries' / 'to' / 'trailing' / 'true' /
      'unbounded' / 'union' / 'unique' / 'unsegmented' / 'user' / 'using' /
      'when' / 'where' / 'window' / 'within' / 'with'
    )
    word_boundary
      #    <SQLKeyword>
  end

  #   bit varying [ (n) ]	varbit [ (n) ]
  rule bit_varying_type
    ( 'bit varying'  /  'bit' / 'varbit' ) integer_in_parenthese?
      #    <BitVaryingType>
  end

  # character [ (n) ]	char [ (n) ]
  rule character_type
   (  'character' / 'char') integer_in_parenthese?
      #   <CharacterType>
  end

  # character varying [ (n) ]	varchar [ (n) ]
  rule character_varying_type
    ( 'character varying' / 'varchar' ) integer_in_parenthese?
      #    <VarCharType>
  end

  rule integer_in_parenthese
    ( '(' s [0-9]+ s ')' )
      #    <IntegerInParentheses>
  end

  #  numeric [ (p, s) ]	decimal [ (p, s) ]
  rule numeric_type
    ('numeric' / 'decimal' ) number_precision?
    #    <NumericType>
  end

  #  float [ (p, s) ]	decimal [ (p, s) ]
  rule float_type
    'float' number_precision?
    #    <FloatType>
  end

  rule number_precision
    '(' s [0-9]+ (s ',' s [0-9]+)?  s ')'
  end


  rule list_separator
    [\s]* ',' [\s]*
    #    <ListSeparator>
  end


  # =============================
  #  Whitespace and comments
  #
  #  Here are four whitespace helpers:
  #    s in the name means “space”,
  #    n means newline,
  #   and capitalization means that the capitalized part is REQUIRED
  #      (contrary to being optional).
  #
  #  from https://whitequark.org/blog/2011/09/08/treetop-typical-errors/
  # =============================

  # optional space
  rule s
    S?
  end

  # REQUIRED one or more spaces or tabs
  rule S
    [ \t]+
  end

  # optional blank line (optionally with leading spaces or tabs)
  rule sn
    sN?
  end

  rule comment_line
    comment_marker (!"\n" .)* "\n"  #<CommentLine>
  end

  rule comment_marker
    '--'
  end

  # REQUIRED NEWLINE
  # optional spaces followed by a newline
  #   or
  # optional comment line followed by a newline
  rule sN
    ( ( S "\n" / s comment_line / s "\n" ) s comment_line? )+
  end

end
